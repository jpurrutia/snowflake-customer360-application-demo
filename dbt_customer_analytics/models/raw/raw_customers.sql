{{
    config(
        materialized='incremental',
        unique_key='customer_id',
        on_schema_change='fail',
        tags=['bronze', 'customers', 'incremental']
    )
}}

{#
============================================================================
Bronze Model: Raw Customers
============================================================================
Purpose: Load customer data from internal stage (@customer_data_stage) into Bronze layer

Source: Parquet files generated by BRONZE.GENERATE_CUSTOMERS() stored procedure

Transformations: NONE (Bronze layer accepts data as-is from source)

Incremental Strategy:
- Materialized as incremental table
- unique_key: customer_id (upsert on conflict)
- Processes only new files in stage

Quality Checks:
- Unique customer_ids (enforced by incremental unique_key)
- All expected columns present

Usage:
1. Generate data: CALL BRONZE.GENERATE_CUSTOMERS(50000, 42);
2. Load to Bronze: dbt run --select bronze.raw_customers
3. Verify: SELECT COUNT(*) FROM {{ this }};
============================================================================
#}

{% if is_incremental() %}

-- Incremental load: only copy files not already loaded
COPY INTO {{ this }} (
    customer_id,
    first_name,
    last_name,
    email,
    age,
    state,
    city,
    employment_status,
    card_type,
    credit_limit,
    account_open_date,
    customer_segment,
    decline_type,
    ingestion_timestamp,
    source_file,
    _metadata_file_row_number
)
FROM (
    SELECT
        $1:CUSTOMER_ID::STRING AS customer_id,
        $1:FIRST_NAME::STRING AS first_name,
        $1:LAST_NAME::STRING AS last_name,
        $1:EMAIL::STRING AS email,
        $1:AGE::INT AS age,
        $1:STATE::STRING AS state,
        $1:CITY::STRING AS city,
        $1:EMPLOYMENT_STATUS::STRING AS employment_status,
        $1:CARD_TYPE::STRING AS card_type,
        $1:CREDIT_LIMIT::NUMBER(10,2) AS credit_limit,
        $1:ACCOUNT_OPEN_DATE::DATE AS account_open_date,
        $1:CUSTOMER_SEGMENT::STRING AS customer_segment,
        $1:DECLINE_TYPE::STRING AS decline_type,
        CURRENT_TIMESTAMP() AS ingestion_timestamp,
        METADATA$FILENAME AS source_file,
        METADATA$FILE_ROW_NUMBER AS _metadata_file_row_number
    FROM @CUSTOMER_ANALYTICS.BRONZE.customer_data_stage
)
FILE_FORMAT = (TYPE = 'PARQUET')
PATTERN = '.*customers_seed.*\.parquet'
ON_ERROR = 'ABORT_STATEMENT'
FORCE = FALSE  -- Skip already-loaded files

{% else %}

-- Initial full load
COPY INTO {{ this }} (
    customer_id,
    first_name,
    last_name,
    email,
    age,
    state,
    city,
    employment_status,
    card_type,
    credit_limit,
    account_open_date,
    customer_segment,
    decline_type,
    ingestion_timestamp,
    source_file,
    _metadata_file_row_number
)
FROM (
    SELECT
        $1:CUSTOMER_ID::STRING AS customer_id,
        $1:FIRST_NAME::STRING AS first_name,
        $1:LAST_NAME::STRING AS last_name,
        $1:EMAIL::STRING AS email,
        $1:AGE::INT AS age,
        $1:STATE::STRING AS state,
        $1:CITY::STRING AS city,
        $1:EMPLOYMENT_STATUS::STRING AS employment_status,
        $1:CARD_TYPE::STRING AS card_type,
        $1:CREDIT_LIMIT::NUMBER(10,2) AS credit_limit,
        $1:ACCOUNT_OPEN_DATE::DATE AS account_open_date,
        $1:CUSTOMER_SEGMENT::STRING AS customer_segment,
        $1:DECLINE_TYPE::STRING AS decline_type,
        CURRENT_TIMESTAMP() AS ingestion_timestamp,
        METADATA$FILENAME AS source_file,
        METADATA$FILE_ROW_NUMBER AS _metadata_file_row_number
    FROM @CUSTOMER_ANALYTICS.BRONZE.customer_data_stage
)
FILE_FORMAT = (TYPE = 'PARQUET')
PATTERN = '.*customers_seed.*\.parquet'
ON_ERROR = 'ABORT_STATEMENT'

{% endif %}
